{"ast":null,"code":"'use client';\n\nimport { useState, useCallback } from 'react';\nimport { getAllCheckedNodes } from './get-all-checked-nodes/get-all-checked-nodes.mjs';\nimport { getChildrenNodesValues, getAllChildrenNodes } from './get-children-nodes-values/get-children-nodes-values.mjs';\nimport { memoizedIsNodeChecked } from './is-node-checked/is-node-checked.mjs';\nimport { memoizedIsNodeIndeterminate } from './is-node-indeterminate/is-node-indeterminate.mjs';\nfunction getInitialTreeExpandedState(initialState, data, value, acc = {}) {\n  data.forEach(node => {\n    acc[node.value] = node.value in initialState ? initialState[node.value] : node.value === value;\n    if (Array.isArray(node.children)) {\n      getInitialTreeExpandedState(initialState, node.children, value, acc);\n    }\n  });\n  return acc;\n}\nfunction getTreeExpandedState(data, expandedNodesValues) {\n  const state = getInitialTreeExpandedState({}, data, []);\n  if (expandedNodesValues === \"*\") {\n    return Object.keys(state).reduce((acc, key) => ({\n      ...acc,\n      [key]: true\n    }), {});\n  }\n  expandedNodesValues.forEach(node => {\n    state[node] = true;\n  });\n  return state;\n}\nfunction getInitialCheckedState(initialState, data) {\n  const acc = [];\n  initialState.forEach(node => acc.push(...getChildrenNodesValues(node, data)));\n  return Array.from(new Set(acc));\n}\nfunction useTree({\n  initialSelectedState = [],\n  initialCheckedState = [],\n  initialExpandedState = {},\n  multiple = false,\n  onNodeCollapse,\n  onNodeExpand\n} = {}) {\n  const [data, setData] = useState([]);\n  const [expandedState, setExpandedState] = useState(initialExpandedState);\n  const [selectedState, setSelectedState] = useState(initialSelectedState);\n  const [checkedState, setCheckedState] = useState(initialCheckedState);\n  const [anchorNode, setAnchorNode] = useState(null);\n  const [hoveredNode, setHoveredNode] = useState(null);\n  const initialize = useCallback(_data => {\n    setExpandedState(current => getInitialTreeExpandedState(current, _data, selectedState));\n    setCheckedState(current => getInitialCheckedState(current, _data));\n    setData(_data);\n  }, [selectedState, checkedState]);\n  const toggleExpanded = useCallback(value => {\n    setExpandedState(current => {\n      const nextState = {\n        ...current,\n        [value]: !current[value]\n      };\n      nextState[value] ? onNodeExpand?.(value) : onNodeCollapse?.(value);\n      return nextState;\n    });\n  }, [onNodeCollapse, onNodeExpand]);\n  const collapse = useCallback(value => {\n    setExpandedState(current => {\n      if (current[value] !== false) {\n        onNodeCollapse?.(value);\n      }\n      return {\n        ...current,\n        [value]: false\n      };\n    });\n  }, [onNodeCollapse]);\n  const expand = useCallback(value => {\n    setExpandedState(current => {\n      if (current[value] !== true) {\n        onNodeExpand?.(value);\n      }\n      return {\n        ...current,\n        [value]: true\n      };\n    });\n  }, [onNodeExpand]);\n  const expandAllNodes = useCallback(() => {\n    setExpandedState(current => {\n      const next = {\n        ...current\n      };\n      Object.keys(next).forEach(key => {\n        next[key] = true;\n      });\n      return next;\n    });\n  }, []);\n  const collapseAllNodes = useCallback(() => {\n    setExpandedState(current => {\n      const next = {\n        ...current\n      };\n      Object.keys(next).forEach(key => {\n        next[key] = false;\n      });\n      return next;\n    });\n  }, []);\n  const toggleSelected = useCallback(value => setSelectedState(current => {\n    if (!multiple) {\n      if (current.includes(value)) {\n        setAnchorNode(null);\n        return [];\n      }\n      setAnchorNode(value);\n      return [value];\n    }\n    if (current.includes(value)) {\n      setAnchorNode(null);\n      return current.filter(item => item !== value);\n    }\n    setAnchorNode(value);\n    return [...current, value];\n  }), []);\n  const select = useCallback(value => {\n    setAnchorNode(value);\n    setSelectedState(current => multiple ? current.includes(value) ? current : [...current, value] : [value]);\n  }, []);\n  const deselect = useCallback(value => {\n    anchorNode === value && setAnchorNode(null);\n    setSelectedState(current => current.filter(item => item !== value));\n  }, []);\n  const clearSelected = useCallback(() => {\n    setSelectedState([]);\n    setAnchorNode(null);\n  }, []);\n  const checkNode = useCallback(value => {\n    const checkedNodes = getChildrenNodesValues(value, data);\n    setCheckedState(current => Array.from( /* @__PURE__ */new Set([...current, ...checkedNodes])));\n  }, [data]);\n  const uncheckNode = useCallback(value => {\n    const checkedNodes = getChildrenNodesValues(value, data);\n    setCheckedState(current => current.filter(item => !checkedNodes.includes(item)));\n  }, [data]);\n  const checkAllNodes = useCallback(() => {\n    setCheckedState(() => getAllChildrenNodes(data));\n  }, [data]);\n  const uncheckAllNodes = useCallback(() => {\n    setCheckedState([]);\n  }, []);\n  const getCheckedNodes = () => getAllCheckedNodes(data, checkedState).result;\n  const isNodeChecked = value => memoizedIsNodeChecked(value, data, checkedState);\n  const isNodeIndeterminate = value => memoizedIsNodeIndeterminate(value, data, checkedState);\n  return {\n    multiple,\n    expandedState,\n    selectedState,\n    checkedState,\n    anchorNode,\n    initialize,\n    toggleExpanded,\n    collapse,\n    expand,\n    expandAllNodes,\n    collapseAllNodes,\n    setExpandedState,\n    checkNode,\n    uncheckNode,\n    checkAllNodes,\n    uncheckAllNodes,\n    setCheckedState,\n    toggleSelected,\n    select,\n    deselect,\n    clearSelected,\n    setSelectedState,\n    hoveredNode,\n    setHoveredNode,\n    getCheckedNodes,\n    isNodeChecked,\n    isNodeIndeterminate\n  };\n}\nexport { getTreeExpandedState, useTree };","map":{"version":3,"names":["getInitialTreeExpandedState","initialState","data","value","acc","forEach","node","Array","isArray","children","getTreeExpandedState","expandedNodesValues","state","Object","keys","reduce","key","getInitialCheckedState","push","getChildrenNodesValues","from","Set","useTree","initialSelectedState","initialCheckedState","initialExpandedState","multiple","onNodeCollapse","onNodeExpand","setData","useState","expandedState","setExpandedState","selectedState","setSelectedState","checkedState","setCheckedState","anchorNode","setAnchorNode","hoveredNode","setHoveredNode","initialize","useCallback","_data","current","toggleExpanded","nextState","collapse","expand","expandAllNodes","next","collapseAllNodes","toggleSelected","includes","filter","item","select","deselect","clearSelected","checkNode","checkedNodes","uncheckNode","checkAllNodes","getAllChildrenNodes","uncheckAllNodes","getCheckedNodes","getAllCheckedNodes","result","isNodeChecked","memoizedIsNodeChecked","isNodeIndeterminate","memoizedIsNodeIndeterminate"],"sources":["/Users/clarencechau/Documents/projects/personal-website/clarencechau.github.io/node_modules/@mantine/core/src/components/Tree/use-tree.ts"],"sourcesContent":["import { useCallback, useState } from 'react';\nimport {\n  CheckedNodeStatus,\n  getAllCheckedNodes,\n} from './get-all-checked-nodes/get-all-checked-nodes';\nimport {\n  getAllChildrenNodes,\n  getChildrenNodesValues,\n} from './get-children-nodes-values/get-children-nodes-values';\nimport { memoizedIsNodeChecked } from './is-node-checked/is-node-checked';\nimport { memoizedIsNodeIndeterminate } from './is-node-indeterminate/is-node-indeterminate';\nimport type { TreeNodeData } from './Tree';\n\nexport type TreeExpandedState = Record<string, boolean>;\n\nfunction getInitialTreeExpandedState(\n  initialState: TreeExpandedState,\n  data: TreeNodeData[],\n  value: string | string[] | undefined,\n  acc: TreeExpandedState = {}\n) {\n  data.forEach((node) => {\n    acc[node.value] = node.value in initialState ? initialState[node.value] : node.value === value;\n\n    if (Array.isArray(node.children)) {\n      getInitialTreeExpandedState(initialState, node.children, value, acc);\n    }\n  });\n\n  return acc;\n}\n\nexport function getTreeExpandedState(data: TreeNodeData[], expandedNodesValues: string[] | '*') {\n  const state = getInitialTreeExpandedState({}, data, []);\n\n  if (expandedNodesValues === '*') {\n    return Object.keys(state).reduce((acc, key) => ({ ...acc, [key]: true }), {});\n  }\n\n  expandedNodesValues.forEach((node) => {\n    state[node] = true;\n  });\n\n  return state;\n}\n\nfunction getInitialCheckedState(initialState: string[], data: TreeNodeData[]) {\n  const acc: string[] = [];\n\n  initialState.forEach((node) => acc.push(...getChildrenNodesValues(node, data)));\n\n  return Array.from(new Set(acc));\n}\n\nexport interface UseTreeInput {\n  /** Initial expanded state of all nodes */\n  initialExpandedState?: TreeExpandedState;\n\n  /** Initial selected state of nodes */\n  initialSelectedState?: string[];\n\n  /** Initial checked state of nodes */\n  initialCheckedState?: string[];\n\n  /** Determines whether multiple node can be selected at a time */\n  multiple?: boolean;\n\n  /** Called with the node value when it is expanded */\n  onNodeExpand?: (value: string) => void;\n\n  /** Called with the node value when it is collapsed */\n  onNodeCollapse?: (value: string) => void;\n}\n\nexport interface UseTreeReturnType {\n  /** Determines whether multiple node can be selected at a time */\n  multiple: boolean;\n\n  /** A record of `node.value` and boolean values that represent nodes expanded state */\n  expandedState: TreeExpandedState;\n\n  /** An array of selected nodes values */\n  selectedState: string[];\n\n  /** An array of checked nodes values */\n  checkedState: string[];\n\n  /** A value of the node that was last clicked\n   * Anchor node is used to determine range of selected nodes for multiple selection\n   */\n  anchorNode: string | null;\n\n  /** Initializes tree state based on provided data, called automatically by the Tree component */\n  initialize: (data: TreeNodeData[]) => void;\n\n  /** Toggles expanded state of the node with provided value */\n  toggleExpanded: (value: string) => void;\n\n  /** Collapses node with provided value */\n  collapse: (value: string) => void;\n\n  /** Expands node with provided value */\n  expand: (value: string) => void;\n\n  /** Expands all nodes */\n  expandAllNodes: () => void;\n\n  /** Collapses all nodes */\n  collapseAllNodes: () => void;\n\n  /** Sets expanded state */\n  setExpandedState: React.Dispatch<React.SetStateAction<TreeExpandedState>>;\n\n  /** Toggles selected state of the node with provided value */\n  toggleSelected: (value: string) => void;\n\n  /** Selects node with provided value */\n  select: (value: string) => void;\n\n  /** Deselects node with provided value */\n  deselect: (value: string) => void;\n\n  /** Clears selected state */\n  clearSelected: () => void;\n\n  /** Sets selected state */\n  setSelectedState: React.Dispatch<React.SetStateAction<string[]>>;\n\n  /** A value of the node that is currently hovered */\n  hoveredNode: string | null;\n\n  /** Sets hovered node */\n  setHoveredNode: React.Dispatch<React.SetStateAction<string | null>>;\n\n  /** Checks node with provided value */\n  checkNode: (value: string) => void;\n\n  /** Unchecks node with provided value */\n  uncheckNode: (value: string) => void;\n\n  /** Checks all nodes */\n  checkAllNodes: () => void;\n\n  /** Unchecks all nodes */\n  uncheckAllNodes: () => void;\n\n  /** Sets checked state */\n  setCheckedState: React.Dispatch<React.SetStateAction<string[]>>;\n\n  /** Returns all checked nodes with status */\n  getCheckedNodes: () => CheckedNodeStatus[];\n\n  /** Returns `true` if node with provided value is checked */\n  isNodeChecked: (value: string) => boolean;\n\n  /** Returns `true` if node with provided value is indeterminate */\n  isNodeIndeterminate: (value: string) => boolean;\n}\n\nexport function useTree({\n  initialSelectedState = [],\n  initialCheckedState = [],\n  initialExpandedState = {},\n  multiple = false,\n  onNodeCollapse,\n  onNodeExpand,\n}: UseTreeInput = {}): UseTreeReturnType {\n  const [data, setData] = useState<TreeNodeData[]>([]);\n  const [expandedState, setExpandedState] = useState(initialExpandedState);\n  const [selectedState, setSelectedState] = useState(initialSelectedState);\n  const [checkedState, setCheckedState] = useState(initialCheckedState);\n  const [anchorNode, setAnchorNode] = useState<string | null>(null);\n  const [hoveredNode, setHoveredNode] = useState<string | null>(null);\n\n  const initialize = useCallback(\n    (_data: TreeNodeData[]) => {\n      setExpandedState((current) => getInitialTreeExpandedState(current, _data, selectedState));\n      setCheckedState((current) => getInitialCheckedState(current, _data));\n      setData(_data);\n    },\n    [selectedState, checkedState]\n  );\n\n  const toggleExpanded = useCallback(\n    (value: string) => {\n      setExpandedState((current) => {\n        const nextState = { ...current, [value]: !current[value] };\n        nextState[value] ? onNodeExpand?.(value) : onNodeCollapse?.(value);\n        return nextState;\n      });\n    },\n    [onNodeCollapse, onNodeExpand]\n  );\n\n  const collapse = useCallback(\n    (value: string) => {\n      setExpandedState((current) => {\n        if (current[value] !== false) {\n          onNodeCollapse?.(value);\n        }\n\n        return { ...current, [value]: false };\n      });\n    },\n    [onNodeCollapse]\n  );\n\n  const expand = useCallback(\n    (value: string) => {\n      setExpandedState((current) => {\n        if (current[value] !== true) {\n          onNodeExpand?.(value);\n        }\n\n        return { ...current, [value]: true };\n      });\n    },\n    [onNodeExpand]\n  );\n\n  const expandAllNodes = useCallback(() => {\n    setExpandedState((current) => {\n      const next = { ...current };\n      Object.keys(next).forEach((key) => {\n        next[key] = true;\n      });\n\n      return next;\n    });\n  }, []);\n\n  const collapseAllNodes = useCallback(() => {\n    setExpandedState((current) => {\n      const next = { ...current };\n      Object.keys(next).forEach((key) => {\n        next[key] = false;\n      });\n\n      return next;\n    });\n  }, []);\n\n  const toggleSelected = useCallback(\n    (value: string) =>\n      setSelectedState((current) => {\n        if (!multiple) {\n          if (current.includes(value)) {\n            setAnchorNode(null);\n            return [];\n          }\n\n          setAnchorNode(value);\n          return [value];\n        }\n\n        if (current.includes(value)) {\n          setAnchorNode(null);\n          return current.filter((item) => item !== value);\n        }\n\n        setAnchorNode(value);\n\n        return [...current, value];\n      }),\n    []\n  );\n\n  const select = useCallback((value: string) => {\n    setAnchorNode(value);\n    setSelectedState((current) =>\n      multiple ? (current.includes(value) ? current : [...current, value]) : [value]\n    );\n  }, []);\n\n  const deselect = useCallback((value: string) => {\n    anchorNode === value && setAnchorNode(null);\n    setSelectedState((current) => current.filter((item) => item !== value));\n  }, []);\n\n  const clearSelected = useCallback(() => {\n    setSelectedState([]);\n    setAnchorNode(null);\n  }, []);\n\n  const checkNode = useCallback(\n    (value: string) => {\n      const checkedNodes = getChildrenNodesValues(value, data);\n      setCheckedState((current) => Array.from(new Set([...current, ...checkedNodes])));\n    },\n    [data]\n  );\n\n  const uncheckNode = useCallback(\n    (value: string) => {\n      const checkedNodes = getChildrenNodesValues(value, data);\n      setCheckedState((current) => current.filter((item) => !checkedNodes.includes(item)));\n    },\n    [data]\n  );\n\n  const checkAllNodes = useCallback(() => {\n    setCheckedState(() => getAllChildrenNodes(data));\n  }, [data]);\n\n  const uncheckAllNodes = useCallback(() => {\n    setCheckedState([]);\n  }, []);\n\n  const getCheckedNodes = () => getAllCheckedNodes(data, checkedState).result;\n  const isNodeChecked = (value: string) => memoizedIsNodeChecked(value, data, checkedState);\n  const isNodeIndeterminate = (value: string) =>\n    memoizedIsNodeIndeterminate(value, data, checkedState);\n\n  return {\n    multiple,\n    expandedState,\n    selectedState,\n    checkedState,\n    anchorNode,\n    initialize,\n\n    toggleExpanded,\n    collapse,\n    expand,\n    expandAllNodes,\n    collapseAllNodes,\n    setExpandedState,\n\n    checkNode,\n    uncheckNode,\n    checkAllNodes,\n    uncheckAllNodes,\n    setCheckedState,\n\n    toggleSelected,\n    select,\n    deselect,\n    clearSelected,\n    setSelectedState,\n\n    hoveredNode,\n    setHoveredNode,\n    getCheckedNodes,\n    isNodeChecked,\n    isNodeIndeterminate,\n  };\n}\n\nexport type TreeController = ReturnType<typeof useTree>;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}