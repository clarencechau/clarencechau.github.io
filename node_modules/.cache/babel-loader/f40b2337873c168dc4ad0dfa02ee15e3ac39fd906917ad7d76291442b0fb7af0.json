{"ast":null,"code":"'use client';\n\nimport { jsx } from 'react/jsx-runtime';\nimport { forwardRef, useState, useEffect } from 'react';\nimport { useDebouncedCallback } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context.mjs';\nimport { composeEventHandlers } from '../utils/compose-event-handlers.mjs';\nimport { ScrollAreaScrollbarVisible } from './ScrollAreaScrollbarVisible.mjs';\nconst ScrollAreaScrollbarScroll = forwardRef((props, red) => {\n  const {\n    forceMount,\n    ...scrollbarProps\n  } = props;\n  const context = useScrollAreaContext();\n  const isHorizontal = props.orientation === \"horizontal\";\n  const [state, setState] = useState(\"hidden\");\n  const debounceScrollEnd = useDebouncedCallback(() => setState(\"idle\"), 100);\n  useEffect(() => {\n    if (state === \"idle\") {\n      const hideTimer = window.setTimeout(() => setState(\"hidden\"), context.scrollHideDelay);\n      return () => window.clearTimeout(hideTimer);\n    }\n    return void 0;\n  }, [state, context.scrollHideDelay]);\n  useEffect(() => {\n    const {\n      viewport\n    } = context;\n    const scrollDirection = isHorizontal ? \"scrollLeft\" : \"scrollTop\";\n    if (viewport) {\n      let prevScrollPos = viewport[scrollDirection];\n      const handleScroll = () => {\n        const scrollPos = viewport[scrollDirection];\n        const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;\n        if (hasScrollInDirectionChanged) {\n          setState(\"scrolling\");\n          debounceScrollEnd();\n        }\n        prevScrollPos = scrollPos;\n      };\n      viewport.addEventListener(\"scroll\", handleScroll);\n      return () => viewport.removeEventListener(\"scroll\", handleScroll);\n    }\n    return void 0;\n  }, [context.viewport, isHorizontal, debounceScrollEnd]);\n  if (forceMount || state !== \"hidden\") {\n    return /* @__PURE__ */jsx(ScrollAreaScrollbarVisible, {\n      \"data-state\": state === \"hidden\" ? \"hidden\" : \"visible\",\n      ...scrollbarProps,\n      ref: red,\n      onPointerEnter: composeEventHandlers(props.onPointerEnter, () => setState(\"interacting\")),\n      onPointerLeave: composeEventHandlers(props.onPointerLeave, () => setState(\"idle\"))\n    });\n  }\n  return null;\n});\nexport { ScrollAreaScrollbarScroll };","map":{"version":3,"names":["ScrollAreaScrollbarScroll","forwardRef","props","red","forceMount","scrollbarProps","context","useScrollAreaContext","isHorizontal","orientation","state","setState","useState","debounceScrollEnd","useDebouncedCallback","useEffect","hideTimer","window","setTimeout","scrollHideDelay","clearTimeout","viewport","scrollDirection","prevScrollPos","handleScroll","scrollPos","hasScrollInDirectionChanged","addEventListener","removeEventListener","jsx","ScrollAreaScrollbarVisible","ref","onPointerEnter","composeEventHandlers","onPointerLeave"],"sources":["/Users/clarencechau/Documents/projects/personal-website/clarencechau.github.io/node_modules/@mantine/core/src/components/ScrollArea/ScrollAreaScrollbar/ScrollAreaScrollbarScroll.tsx"],"sourcesContent":["import { forwardRef, useEffect, useState } from 'react';\nimport { useDebouncedCallback } from '@mantine/hooks';\nimport { useScrollAreaContext } from '../ScrollArea.context';\nimport { composeEventHandlers } from '../utils';\nimport {\n  ScrollAreaScrollbarVisible,\n  ScrollAreaScrollbarVisibleProps,\n} from './ScrollAreaScrollbarVisible';\n\ninterface ScrollAreaScrollbarScrollProps extends ScrollAreaScrollbarVisibleProps {\n  forceMount?: true;\n}\n\nexport const ScrollAreaScrollbarScroll = forwardRef<HTMLDivElement, ScrollAreaScrollbarScrollProps>(\n  (props, red) => {\n    const { forceMount, ...scrollbarProps } = props;\n    const context = useScrollAreaContext();\n    const isHorizontal = props.orientation === 'horizontal';\n    const [state, setState] = useState<'hidden' | 'idle' | 'interacting' | 'scrolling'>('hidden');\n    const debounceScrollEnd = useDebouncedCallback(() => setState('idle'), 100);\n\n    useEffect(() => {\n      if (state === 'idle') {\n        const hideTimer = window.setTimeout(() => setState('hidden'), context.scrollHideDelay);\n        return () => window.clearTimeout(hideTimer);\n      }\n\n      return undefined;\n    }, [state, context.scrollHideDelay]);\n\n    useEffect(() => {\n      const { viewport } = context;\n      const scrollDirection = isHorizontal ? 'scrollLeft' : 'scrollTop';\n\n      if (viewport) {\n        let prevScrollPos = viewport[scrollDirection];\n        const handleScroll = () => {\n          const scrollPos = viewport[scrollDirection];\n          const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;\n          if (hasScrollInDirectionChanged) {\n            setState('scrolling');\n            debounceScrollEnd();\n          }\n          prevScrollPos = scrollPos;\n        };\n        viewport.addEventListener('scroll', handleScroll);\n        return () => viewport.removeEventListener('scroll', handleScroll);\n      }\n\n      return undefined;\n    }, [context.viewport, isHorizontal, debounceScrollEnd]);\n\n    if (forceMount || state !== 'hidden') {\n      return (\n        <ScrollAreaScrollbarVisible\n          data-state={state === 'hidden' ? 'hidden' : 'visible'}\n          {...scrollbarProps}\n          ref={red}\n          onPointerEnter={composeEventHandlers(props.onPointerEnter, () => setState('interacting'))}\n          onPointerLeave={composeEventHandlers(props.onPointerLeave, () => setState('idle'))}\n        />\n      );\n    }\n\n    return null;\n  }\n);\n"],"mappings":";;;;;;;;AASY,MAACA,yBAAyB,GAAGC,UAAU,CACjD,CAACC,KAAK,EAAEC,GAAG,KAAK;EACd,MAAM;IAAEC,UAAU;IAAE,GAAGC;EAAc,CAAE,GAAGH,KAAK;EAC/C,MAAMI,OAAO,GAAGC,oBAAoB,CAAE;EACtC,MAAMC,YAAY,GAAGN,KAAK,CAACO,WAAW,KAAK,YAAY;EACvD,MAAM,CAACC,KAAK,EAAEC,QAAQ,CAAC,GAAGC,QAAQ,CAAC,QAAQ,CAAC;EAC5C,MAAMC,iBAAiB,GAAGC,oBAAoB,CAAC,MAAMH,QAAQ,CAAC,MAAM,CAAC,EAAE,GAAG,CAAC;EAC3EI,SAAS,CAAC,MAAM;IACd,IAAIL,KAAK,KAAK,MAAM,EAAE;MACpB,MAAMM,SAAS,GAAGC,MAAM,CAACC,UAAU,CAAC,MAAMP,QAAQ,CAAC,QAAQ,CAAC,EAAEL,OAAO,CAACa,eAAe,CAAC;MACtF,OAAO,MAAMF,MAAM,CAACG,YAAY,CAACJ,SAAS,CAAC;IACnD;IACM,OAAO,KAAK,CAAC;EACd,GAAE,CAACN,KAAK,EAAEJ,OAAO,CAACa,eAAe,CAAC,CAAC;EACpCJ,SAAS,CAAC,MAAM;IACd,MAAM;MAAEM;IAAQ,CAAE,GAAGf,OAAO;IAC5B,MAAMgB,eAAe,GAAGd,YAAY,GAAG,YAAY,GAAG,WAAW;IACjE,IAAIa,QAAQ,EAAE;MACZ,IAAIE,aAAa,GAAGF,QAAQ,CAACC,eAAe,CAAC;MAC7C,MAAME,YAAY,GAAGA,CAAA,KAAM;QACzB,MAAMC,SAAS,GAAGJ,QAAQ,CAACC,eAAe,CAAC;QAC3C,MAAMI,2BAA2B,GAAGH,aAAa,KAAKE,SAAS;QAC/D,IAAIC,2BAA2B,EAAE;UAC/Bf,QAAQ,CAAC,WAAW,CAAC;UACrBE,iBAAiB,CAAE;QAC/B;QACUU,aAAa,GAAGE,SAAS;MAC1B;MACDJ,QAAQ,CAACM,gBAAgB,CAAC,QAAQ,EAAEH,YAAY,CAAC;MACjD,OAAO,MAAMH,QAAQ,CAACO,mBAAmB,CAAC,QAAQ,EAAEJ,YAAY,CAAC;IACzE;IACM,OAAO,KAAK,CAAC;EACd,GAAE,CAAClB,OAAO,CAACe,QAAQ,EAAEb,YAAY,EAAEK,iBAAiB,CAAC,CAAC;EACvD,IAAIT,UAAU,IAAIM,KAAK,KAAK,QAAQ,EAAE;IACpC,sBAAuBmB,GAAG,CACxBC,0BAA0B,EAC1B;MACE,YAAY,EAAEpB,KAAK,KAAK,QAAQ,GAAG,QAAQ,GAAG,SAAS;MACvD,GAAGL,cAAc;MACjB0B,GAAG,EAAE5B,GAAG;MACR6B,cAAc,EAAEC,oBAAoB,CAAC/B,KAAK,CAAC8B,cAAc,EAAE,MAAMrB,QAAQ,CAAC,aAAa,CAAC,CAAC;MACzFuB,cAAc,EAAED,oBAAoB,CAAC/B,KAAK,CAACgC,cAAc,EAAE,MAAMvB,QAAQ,CAAC,MAAM,CAAC;IAC3F,CACO;EACP;EACI,OAAO,IAAI;AACf,CACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}